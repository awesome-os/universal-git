
// [do not edit,<auto-generated />]
// This file has been automatically generated, please do not change unless you disable auto-generation in the Makefile  
#include <mach/mach.h>
#include <mach-o/dyld.h>
#include <lo.h>

namespace lo {
namespace mach {

using v8::String;
using v8::FunctionCallbackInfo;
using v8::Array;
using v8::Local;
using v8::ObjectTemplate;
using v8::Isolate;
using v8::Value;
using v8::Uint32Array;
using v8::ArrayBuffer;
using v8::Context;
using v8::Integer;
using v8::Function;
using v8::NewStringType;
using v8::Object;
using v8::BackingStore;
using v8::TryCatch;
using v8::ScriptCompiler;
using v8::Module;
using v8::FixedArray;
using v8::ScriptOrigin;
using v8::SharedArrayBuffer;
using v8::MaybeLocal;
using v8::HandleScope;
using v8::Promise;
using v8::Number;
using v8::StackTrace;
using v8::Message;
using v8::StackFrame;
using v8::Maybe;
using v8::FunctionTemplate;
using v8::FunctionCallback;
using v8::PromiseRejectMessage;
using v8::CFunction;
using v8::Global;
using v8::Exception;
using v8::CTypeInfo;
using v8::PropertyAttribute;
using v8::Signature;
using v8::ConstructorBehavior;
using v8::SideEffectType;
using v8::kPromiseRejectAfterResolved;
using v8::kPromiseResolveAfterResolved;
using v8::kPromiseHandlerAddedAfterReject;
using v8::Data;
using v8::PrimitiveArray;
using v8::TypedArray;
using v8::Uint8Array;
using v8::Boolean;
using v8::ModuleRequest;
using v8::CFunctionInfo;
using v8::OOMDetails;
using v8::V8;
using v8::BigInt;



int32_t task_infoFast(void* p, uint32_t p0, int32_t p1, void* p2, void* p3);
v8::CTypeInfo cargstask_info[5] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
};
v8::CTypeInfo rctask_info = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infotask_info = v8::CFunctionInfo(rctask_info, 5, cargstask_info);
v8::CFunction pFtask_info = v8::CFunction((const void*)&task_infoFast, &infotask_info);

uint32_t task_selfFast(void* p);
v8::CTypeInfo cargstask_self[1] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),

};
v8::CTypeInfo rctask_self = v8::CTypeInfo(v8::CTypeInfo::Type::kUint32);
v8::CFunctionInfo infotask_self = v8::CFunctionInfo(rctask_self, 1, cargstask_self);
v8::CFunction pFtask_self = v8::CFunction((const void*)&task_selfFast, &infotask_self);

int32_t get_executable_pathFast(void* p, void* p0, struct FastApiTypedArray* const p1);
v8::CTypeInfo cargsget_executable_path[3] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
};
v8::CTypeInfo rcget_executable_path = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infoget_executable_path = v8::CFunctionInfo(rcget_executable_path, 3, cargsget_executable_path);
v8::CFunction pFget_executable_path = v8::CFunction((const void*)&get_executable_pathFast, &infoget_executable_path);



void task_infoSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  uint32_t v0 = Local<Integer>::Cast(args[0])->Value();
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  task_info_t v2 = reinterpret_cast<task_info_t>((uint64_t)Local<Integer>::Cast(args[2])->Value());
  mach_msg_type_number_t* v3 = reinterpret_cast<mach_msg_type_number_t*>((uint64_t)Local<Integer>::Cast(args[3])->Value());
  int32_t rc = task_info(v0, v1, v2, v3);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t task_infoFast(void* p, uint32_t p0, int32_t p1, void* p2, void* p3) {
  uint32_t v0 = p0;
  int32_t v1 = p1;
  task_info_t v2 = reinterpret_cast<task_info_t>(p2);
  mach_msg_type_number_t* v3 = reinterpret_cast<mach_msg_type_number_t*>(p3);
  return task_info(v0, v1, v2, v3);
}
void task_selfSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();

  uint32_t rc = mach_task_self();
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

uint32_t task_selfFast(void* p) {

  return mach_task_self();
}
void get_executable_pathSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  char* v0 = reinterpret_cast<char*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  Local<Uint32Array> u321 = args[1].As<Uint32Array>();
  uint8_t* ptr1 = (uint8_t*)u321->Buffer()->Data() + u321->ByteOffset();
  uint32_t* v1 = reinterpret_cast<uint32_t*>(ptr1);
  int32_t rc = _NSGetExecutablePath(v0, v1);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t get_executable_pathFast(void* p, void* p0, struct FastApiTypedArray* const p1) {
  char* v0 = reinterpret_cast<char*>(p0);
  uint32_t* v1 = reinterpret_cast<uint32_t*>(p1->data);
  return _NSGetExecutablePath(v0, v1);
}

void Init(Isolate* isolate, Local<ObjectTemplate> target) {
  Local<ObjectTemplate> module = ObjectTemplate::New(isolate);
  SET_FAST_METHOD(isolate, module, "task_info", &pFtask_info, task_infoSlow);
  SET_FAST_METHOD(isolate, module, "task_self", &pFtask_self, task_selfSlow);
  SET_FAST_METHOD(isolate, module, "get_executable_path", &pFget_executable_path, get_executable_pathSlow);

  SET_VALUE(isolate, module, "TASK_BASIC_INFO_COUNT", Integer::New(isolate, (int32_t)TASK_BASIC_INFO_COUNT));
  SET_VALUE(isolate, module, "KERN_SUCCESS", Integer::New(isolate, (int32_t)KERN_SUCCESS));
  SET_VALUE(isolate, module, "TASK_BASIC_INFO", Integer::New(isolate, (int32_t)TASK_BASIC_INFO));

  SET_VALUE(isolate, module, "struct_task_basic_info_size", Integer::New(isolate, sizeof(task_basic_info)));
  SET_VALUE(isolate, module, "struct_mach_msg_type_number_t_size", Integer::New(isolate, sizeof(mach_msg_type_number_t)));

  SET_MODULE(isolate, target, "mach", module);
}
} // namespace mach
} // namespace lo

extern "C" {
  void* _register_mach() {
    return (void*)lo::mach::Init;
  }
}
